\section{Requirements and Design Choices}
The functional requirements the package should meet and how these are met will be described in this section. Functionally speaking, the package should support the computation of the features described in \ref{chapter:03} however there are several layers to achieving this, including the following:

\begin{itemize}
    \item Save/Load location samples on device
    \item Compute intermediate features
    \item Save/Load Stops and Moves on Device
    \item Compute Mobility Features at any time (real-time)
\end{itemize}

Saving and loading of location samples was a necessity in order to not lose data: When an application tracks location data for a pro-longed period of time, i.e. a whole day, it will be sub-optimal to keep all the collected data in RAM, and thereby risking losing it if the app is killed by accident either by the OS or the user. Ideally, for storing the data points collected throughout the day a buffer of data points can be used which, once overflowed will store its elements to the disk. It was also necessary to store Stops and Moves on the device, such that which rely on historic data can be computed in the future. Therefore an interface for easily saving location data points was made, which also allowed the application programmer to load these data points whenever they were required for computation. 

\subsection{Serialization and JSON}
In order to save the SingleLocationPoints from today and historical Stops and Moves on the device they must be transformed from Dart objects into a data format which can store the state of the object, i.e. the information contained within it. The process of doing so is serialization and in this case Dart objects were transformed into JavaScript Object Notation (JSON) objects, which is a very common, human-readable data format that uses key-value pairs to store data. A JSON object can be stored in a database, or it can be transformed to a string in order to be stored. It was chosen to simply transform JSON objects to a string and write them to a local file, rather than storing the information in a database on the phone. The database approach is more involved and was therefore not chosen given the small scope of the project and working from a philosophy of getting a prototype up and running as fast as possible.

JSON supports a limited number of data types, such as strings, numbers, booleans, arrays, objects and null values. This means that in order to translate a Dart object to JSON, all of its fields must be serializable. An example of where this quickly becomes a problem, is with objects such as DateTime objects, since they are not supported by JSON - however a DateTime can be transformed to a number, which is milliseconds since epoch, or to an ISO standard date string. The approach is therefore to look at all the fields of the object that is to be serialized, and ensure that types of these fields all support some form of serialization. If they do not, it must be implemented.

\begin{figure}
    \centering
\begin{minted}{json}
{
    "location": {
        "latitude": 55.11787166161895,
        "longitude": 14.703046919371356
        },
    "datetime": "1586527196999"
}
\end{minted}
    \caption{Example of a serialized SingleLocationDataPoint}
    \label{fig:serialized_point}
\end{figure}

\begin{figure}
    \centering
\begin{minted}{json}
{
    "centroid": {
        "latitude": 55.11787908183754,
        "longitude": 14.703028176721789
        },
    "place_id": 0,
    "arrival": 1586556000999,
    "departure": 1586556697999
}
\end{minted}
    \caption{Example of a serialized Stop}
    \label{fig:serialized_stop}
\end{figure}

\begin{figure}
    \centering
\begin{minted}{json}
{
    "stop_from": {
        "centroid": {
            "latitude": 55.11053332998761,
            "longitude": 14.712282829580444
            },
        "place_id": 6,
        "arrival": 1586694154999,
        "departure": 1586696052001
    },
    "stop_to": {
        "centroid": {
            "latitude": 55.11793063393585,
            "longitude": 14.702982994031046
        },
        "place_id": 0,
        "arrival": 1586697230006,
        "departure": 1586699246824
    },
    "distance":2357.3408321427805
}
\end{minted}
    \caption{Example of a serialized Move}
    \label{fig:serialized_move}
\end{figure}

For loading an object from disk into application memory again it must also support de-serialization which reads values of the JSON object's keys and stores them in a Dart object. If we continue the example of a DateTime object which was serialized by either converting it to a number or a string, de-serialization must use a parser which reads the string bit by bit or use some math for calculating what day a time delta from January 1st 1970 is. 

Serialization and de-serialization is implemented by making an abstract class called Serializable, which has two functions: toJson and fromJson. The toJson function converts the object itself to a JSON object and the fromJson function is a so-called factory function which is in essence a constructor which creates a Dart object given a JSON object. The SingleLocationPoint, Stop and Move classes all implement the Serializable interface, which requires the classes to have a concrete implementation of these two methods, which in turn ensures the compiler that all of these classes can be serialized and de-serialized, which makes generalizing about objects belonging to either of these classes easier. Concretely, a generic class, Serializer<E>, was implemented in order to handle serialization, in which a type E is specified, which must a Serializable class. This makes it efficient in terms of lines of code to serialize a list of objects, since they are all required to implement toJson method, which produces a JSON object, and for de-serialization purposes they can all be constructed from a JSON object, given that it contains a set of correctly formatted key-value pairs.


