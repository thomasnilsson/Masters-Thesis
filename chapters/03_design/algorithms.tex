\section{Algorithms}
These section will give an overview of the algorithms used by the Mobility Features Package. The overview will not discuss implementation details but will aim to get the core idea of each algorithm across.

\subsection{Intermediate Feature Extraction}
The intermediate features \textit{Stops}, \textit{Places} and \textit{Moves} are generated by a relatively simple process. Finding \textit{Places} and \textit{Moves} depends on the \textit{Stops} found, which means \textit{Stops} are found first. 

\subsubsection*{Stops}
Finding \textit{Stops} is done by traversing every \textit{Single Location Points} in temporal order, i.e. the timestamp is used. The \textit{Stops} for a given date are found as clusters of Single Location Points on that date with regard to the time between them, and the physical distance between them. 

\subsubsection*{Places}
Places can now be found by applying the \textit{DBSCAN} algorithm to the \textit{Stops} found. It is important to note that if the \textit{Routine Index} for a given date over a given period is to be evaluated later on, all \textit{Stops} found for this period should be used. This means all \textit{Stops} from previous dates need to be stored on the device. 

\subsubsection*{Moves}
\textit{Moves} for a given can be calculated using the \textit{Stops}- and the \textit{Single Location Points} from that date. The \textit{Moves} are found by going through each \textit{Stop} and calculating the distance between the current \textit{Stop} and the next one by going through all the \textit{Single Location Points} which were sampled in the time interval between these two \textit{Stops}.

\subsection{Features}
The features described in the literature by \cite{Saeb2015} which can be found in Section \ref{ref:features-saeb2015}. Most of these features were simple to implement with support for real-time computation and were just a matter of performing arithmetic with regards to distance and time spent and places. However the \textit{Routine Index} \cite{Saeb2015, Canzian2015} was much more tricky to implement and it will therefore be a recurring theme discussed in this thesis.

\subsubsection*{Real-Time Routine Index}
To recap, the Routine Index describes how similar the place-time distribution of a given day is, compared to previous days for some period of days. A concrete period length of 28 days was chosen, which means the Routine Index of today describes how similar today was to each day during the last month. However the implementation by \cite{Canzian2015} was unnecessarily complex and as such a much more simple version was chosen for the first iteration of the software package. By representing each day 
The \textit{Routine Index} is a scalar between 0 and 1 and can be interpreted as a similarity measure were a low value indicates little overlap and a high value indicates a high degree of overlap. 

We derived a daily Routine Index based on a matrix overlap where the Stops from that day, which in turn are 

\subsubsection*{Hour Matrix}
The time distribution or Hour Matrix can be filled out either in a binary fashion where each stop is iterated and the time slots the stop covers has the entries set to 1, for the place of that stop. This also means that if a time slot contains two places, both of these entries are set to 1.

A more fine-grained approach is to use fill the matrix out based on how many minutes was spent at a place, for each time slot, which can be done by using the arrival- and departure timestamp of each stop. This approach weighs the entries based on how much time was spent, rather than weighing all entries equally.

Given a history of stops, the Routine Index of a given day is computed as the mean of the distances to each day in the history. The distance between two days was computed as the mean over 24 hours where for each hour, if there was a stop in the same location during the two days, the hour was assigned a value of 0, otherwise the hour was assigned a value of 1. We included data available from the previous 28 days (4 weeks) in the history to compute the daily routine index.

$$RI = \frac{\sum (A \cap B)}{\min (\sum A, \sum B)}$$

The numerator $\sum (A \cap B)$ is defined as $\sum_{(i,j) , a_{ij}> 0, b_{ij} > 0} \min (a_{ij}, b_{ij})$.

\subsubsection*{Changing Routines and Home Address}
Most people will go on a vacation during the year, which means the place where they sleep changes during the year. Another example is if someone moves to another place, the place to sleep will in this case also change. A more general problem is that peoples' habits will inevitably change somewhat over time, which does not mean that they do not have a routine. Therefore it was chosen to base the routine index was chosen to be calculated based on the last 4 weeks of data only. 

Another problem which will occur often, and therefore need to be accounted for, is when the user visits new places and the routine index has to be calculated. The solution here is to add the place to the old routine matrix and simply add a zero-column in the routine matrix to represent that place, since there has been no data for that place historically. 

\subsubsection*{Relying on Historical Data}
In order to calculate the routine index we need to save and load the historical data somehow. Two approaches were considered.\\

\textbf{\#1 Saving stops:} By saving all stops for the last 4 weeks, the places can be found by clustering the stops with DBSCAN, and a routine matrix for each day in the last 4 weeks can then be derived and averaged into a routine matrix for that period. Afterwards the routine index can be calculated as the error between today's hour matrix and the historical routine matrix. The author visited 72 stops in a week, which corresponds to around 300 stops for a 4 week period, which is a very manageable number of elements to cluster with DBSCAN.\\

\textbf{\#2 Updating the historical routine matrix:} A historical routine matrix is kept saved on disk and is updated as a weighted average every time a new day's data has been collected and the hour matrix for that day has been calculated. The number of days which the routine matrix is based on will also be kept on the disk, in order to weigh the historical matrix when calculating the new average. However for this approach it becomes necessary to recalculate or at least compare today's places with the historical places every day, in order to keep track of whether the user spend time at a place which exists in the historical matrix, or if it was a completely new place. In this approach the places would need to be saved in addition to a matrix with 24 rows and columns corresponding to each place.

\subsubsection*{Incomplete Days}
In addition, to make the routine index more meaningful in a real-time context, i.e. when requested at some point during the day, and not at 23:59, the calculation was chosen to only rely on historical data from midnight (00:00) to the current last recorded hour. This means the routine index may be high early in the day where the time distribution is likely to be very similar to the historical data, but as the day progresses, there will be more opportunities for the user to deviate from their routine. This can be useful later on if suggestions are to be given to the user; if the routine index falls below a certain threshold, a trigger can be set which will prompt the user to perform a specific action to get back on track.