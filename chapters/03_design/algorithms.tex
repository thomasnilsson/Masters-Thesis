\section{Algorithms}
These section will give an overview of the algorithms used by the Mobility Features Package. The overview will not discuss implementation details but will aim to get the core idea of each algorithm across, in addition to the considerations which were made in designing these algorithms.

\subsection{Intermediate Feature Extraction}
The intermediate features \textit{Stops}, \textit{Places} and \textit{Moves} are generated by a relatively simple process. Finding \textit{Places} and \textit{Moves} depends on the \textit{Stops} found, which means \textit{Stops} are found first. 

\subsubsection*{Stops}
Finding \textit{Stops} is done by traversing every \textit{Single Location Points} in temporal order, i.e. the timestamp is used. The \textit{Stops} for a given date are found as clusters of Single Location Points on that date with regard to the time between them, and the physical distance between them. 

\subsubsection*{Places}
Places can now be found by applying the \textit{DBSCAN} algorithm to the \textit{Stops} found. It is important to note that if the \textit{Routine Index} for a given date over a given period is to be evaluated later on, all \textit{Stops} found for this period should be used. This means all \textit{Stops} from previous dates need to be stored on the device. 

\subsubsection*{Moves}
\textit{Moves} for a given can be calculated using the \textit{Stops}- and the \textit{Single Location Points} from that date. The \textit{Moves} are found by going through each \textit{Stop} and calculating the distance between the current \textit{Stop} and the next one by going through all the \textit{Single Location Points} which were sampled in the time interval between these two \textit{Stops}.

\subsection{Features}
The features described in the literature by \cite{Saeb2015} which can be found in Section \ref{ref:features-saeb2015}. Most of these features were simple to implement with support for real-time computation and were just a matter of performing arithmetic with regards to distance and time spent and places. However the \textit{Routine Index} \cite{Saeb2015, Canzian2015} was much more tricky to implement and it will therefore be a recurring theme discussed in this thesis.

\subsubsection*{The Routine Index}
To recap, the Routine Index describes how similar the place-time distribution of a given day is, compared to previous days for some period of days. A concrete period length of 28 days was chosen, which means the Routine Index of today describes how similar today was to each day during the last month. However the implementation by \cite{Canzian2015} was unnecessarily complex and as such a much more simple version was chosen for the first iteration of the software package. The \textit{Routine Index} is a scalar between 0 and 1 and can be interpreted as a similarity measure were a low value indicates little overlap and a high value indicates a high degree of overlap. 

\subsubsection*{Hour Matrix}
By representing each day as a matrix with 24 hour slots, the similarity function to compute a Routine Index can be implemented. The time distribution for a day is defined by spending a duration of time at a certain space within a certain timeslot, i.e. spending 45 minutes at the gym between 8am and 9am. This matrix is made from all the Stops on a given day, each of which belong to certain \textit{place} and has an \textit{arrival} and \textit{
departure} timestamp. From this it can be calculated exactly which hour slot(s) to fill out and the duration to fill that slot with. For simplicity, we define a couple of constraints on the Hour Matrix:

\begin{itemize}
    \item The Hour Matrix has exactly 24 rows, each representing 1 hour in a day.
    \item The number of columns is equal to the number of places for the period. 
    \item An entry represents the portion of the given hour was spent at a given place.
    \item Each row can maximally sum to 1.
\end{itemize}

Formally, given a period for which the number of places is given as $N$ the \textit{Hour Matrix} $H$ for a given day $d$ is defined as:
$$H^d \in \mathbb{R}^{24 \times N}, H^d_{i,j} \in [0,1], \sum_{j=1}^N H^d_{i,j} \leq 1$$

Given an array of Hour Matrices for a period with $D$ days, the \textit{Mean Hour Matrix} for the period is defined as:

$$H^{\mu}_{i,j} = \sum_{d=1}^D \frac{1}{D} H^d_{i,j}$$

Lastly, we define a union operator $A \cap B$ for two matrices $A$ and $B$ as 

$$\sum (A \cap B) = \sum_{i=1}^{24} \sum_{j=1}^{N} \min (A_{ij}, B_{ij}) \;|\; A_{ij} > 0, B_{ij} > 0$$

The Routine Index of today, indexed as $t=D+1$ is computed as the overlap between the \textit{Hour Matrix} today and the \textit{Mean Hour Matrix} for the period:

$$RI^{t} = \frac{\sum (H^t \cap H^{\mu})}{\min (\sum H^t, \sum H^{\mu})}$$

The dimensions of the two matrices must be exactly the same, and thus the number of places $N$ must come from the complete set of Stops found for the period $D \cup t$. This means that for a high value of $N$, the matrices will be very sparse since one tends not to visit many places in a single hour slot.

\subsubsection*{Real-Time Routine Index}
If the features have to be evaluated at any point of the day, as is the case for real-time computation then the Routine Index cannot rely on a full day of data. To make it truly real-time it would have to reflect the routine of the user up until right now, i.e. if calculated at 14:00 then it should only use the first 14 rows of the matrix. This means the \textit{Routine Index} may be high early in the day where the time distribution is likely to be very similar to the historical data, but as the day progresses, there will be more opportunities for the user to deviate from their routine. This can be useful later on if suggestions are to be given to the user; if the \textit{Routine Index} falls below a certain threshold, a trigger can be set which will prompt the user to perform a specific action to get back on track.

\subsubsection*{Changing Routines and Home Address}
Most people will go on a vacation during the year, which means the place where they sleep changes during the year. Another example is if someone moves to another place, the place to sleep will in this case also change. A more general problem is that peoples' habits will inevitably change somewhat over time, which does not mean that they do not have a routine. Therefore it was chosen to base the routine index was chosen to be calculated based on the last 4 weeks of data only. 

Another problem which will occur often, and therefore need to be accounted for, is when the user visits new places and the routine index has to be calculated. The solution here is to add the place to the old routine matrix and simply add a zero-column in the routine matrix to represent that place, since there has been no data for that place historically. 

\subsubsection*{Relying on Historical Data}
In order to calculate the routine index we need to save and load the historical data somehow. Two approaches were considered.\\

\textbf{\#1 Saving stops:} By saving all stops for the last 4 weeks, the places can be found by clustering the stops with DBSCAN, and a routine matrix for each day in the last 4 weeks can then be derived and averaged into a routine matrix for that period. Afterwards the routine index can be calculated as the error between today's hour matrix and the historical routine matrix. The author visited 72 stops in a week, which corresponds to around 300 stops for a 4 week period, which is a very manageable number of elements to cluster with DBSCAN.\\

\textbf{\#2 Updating the historical routine matrix:} A historical routine matrix is kept saved on disk and is updated as a weighted average every time a new day's data has been collected and the hour matrix for that day has been calculated. The number of days which the routine matrix is based on will also be kept on the disk, in order to weigh the historical matrix when calculating the new average. However for this approach it becomes necessary to recalculate or at least compare today's places with the historical places every day, in order to keep track of whether the user spend time at a place which exists in the historical matrix, or if it was a completely new place. In this approach the places would need to be saved in addition to a matrix with 24 rows and columns corresponding to each place.

