\section{Algorithms}
These section will give an overview of the algorithms used by the Mobility Features Package. The overview will not discuss implementation details but will aim to get the core idea of each algorithm across, in addition to the considerations which were made in designing these algorithms.

\subsection{Intermediate Feature Extraction}
The intermediate features \textit{Stops}, \textit{Places} and \textit{Moves} are generated by a relatively simple process. Finding \textit{Places} and \textit{Moves} depends on the \textit{Stops} found, which means \textit{Stops} are found first. 

\subsubsection*{Stops}
Finding \textit{Stops} is done by traversing every \textit{Single Location Points} in temporal order, i.e. the timestamp is used. The \textit{Stops} for a given date are found as clusters of Single Location Points on that date with regard to the time between them, and the physical distance between them. 

\subsubsection*{Places}
\textit{Places} can now be found by applying the \textit{DBSCAN} algorithm to the \textit{Stops} found. It is important to note that if the \textit{Routine Index} for a given date over a given period is to be evaluated later on, all \textit{Stops} found for this period should be used. This means all \textit{Stops} from previous dates need to be stored on the device. 

\subsubsection*{Moves}
\textit{Moves} for a given can be calculated using the \textit{Stops}- and the \textit{Single Location Points} from that date. The \textit{Moves} are found by going through each \textit{Stop} and calculating the distance between the current \textit{Stop} and the next one by going through all the \textit{Single Location Points} which were sampled in the time interval between these two \textit{Stops}.

\subsection{Features}
The features described in the literature by \cite{Saeb2015} which can be found in Section \ref{ref:features-saeb2015}. Most of these features were simple to implement with support for real-time computation and were just a matter of performing arithmetic with regards to distance and time spent and places. However the \textit{Routine Index} \cite{Saeb2015, Canzian2015} was much more tricky to implement and it will therefore be a recurring theme discussed in this thesis.

\subsubsection*{The Routine Index}
To recap, the \textit{Routine Index} describes how similar the place-time distribution of a given day is, compared to previous days for some period of days. A concrete period length of 28 days was chosen, which means the \textit{Routine Index} of today describes how similar today was to each day during the last month. However the implementation by \cite{Canzian2015} was unnecessarily complex and as such a much more simple version was chosen for the first iteration of the software package. The \textit{Routine Index} is a scalar between 0 and 1 and can be interpreted as a similarity measure were a low value indicates little overlap and a high value indicates a high degree of overlap. 

\subsubsection*{Hour Matrix}
By representing each day as a matrix with 24 hour slots, the similarity function to compute a \textit{Routine Index} can be implemented. The time distribution for a day is defined by spending a duration of time at a certain space within a certain timeslot, i.e. spending 45 minutes at the gym between 8am and 9am. This matrix is made from all the Stops on a given day, each of which belong to certain \textit{place} and has an \textit{arrival} and \textit{
departure} timestamp. From this it can be calculated exactly which hour slot(s) to fill out and the duration to fill that slot with. For simplicity, we define a couple of constraints on the Hour Matrix:

\begin{itemize}
    \item The Hour Matrix has exactly 24 rows, each representing 1 hour in a day.
    \item The number of columns is equal to the number of \textit{Places} for the period. 
    \item An entry represents the portion of the given hour was spent at a given place.
    \item Each row can maximally sum to 1.
\end{itemize}

Formally, given a period for which the number of \textit{Places} is given as $N$ the \textit{Hour Matrix} $H$ for a given day $d$ is defined as:
$$H^d \in \mathbb{R}^{24 \times N}, H^d_{i,j} \in [0,1], \sum_{j=1}^N H^d_{i,j} \leq 1$$

Given an array of Hour Matrices for a period with $D$ days, the \textit{Mean Hour Matrix} for the period is defined as:

$$H^{\mu}_{i,j} = \sum_{d=1}^D \frac{1}{D} H^d_{i,j}$$

Lastly, we define a union operator $A \cap B$ for two matrices $A$ and $B$ as 

$$\sum (A \cap B) = \sum_{i=1}^{24} \sum_{j=1}^{N} \min (A_{ij}, B_{ij}) \;|\; A_{ij} > 0, B_{ij} > 0$$

The \textit{Routine Index} of today, indexed as $t=D+1$ is computed as the overlap between the \textit{Hour Matrix} today and the \textit{Mean Hour Matrix} for the period:

$$RI^{t} = \frac{\sum (H^t \cap H^{\mu})}{\min (\sum H^t, \sum H^{\mu})}$$

The dimensions of the two matrices must be \textit{exactly the same}, and thus the number of \textit{Places} $N$ must come from the complete set of \textit{Stops} found for the period $D \cup t$. This means that for a high value of $N$, the matrices will be very sparse since one tends not to visit many \textit{Places} in a single hour slot.

\subsubsection*{Real-Time Routine Index}
If the features have to be evaluated at any point of the day, as is the case for real-time computation then the \texit{Routine Index} cannot rely on a full day of data. To make the feature represent something meaningful in real-time it would have to reflect the routine of the user up until the current time of days, i.e. if calculated at 14:00 then it should only use the first 14 rows of the matrix. This means the \textit{Routine Index} may be high early in the day since people usually sleep the same place, but then deviate somewhat from the mean as the day progresses. This can be useful to an application programmer in a recommender-system setting; one could imagine that if the \textit{Routine Index} falls below a certain threshold, a trigger can be set which will prompt the user to perform a specific action to get back on track.

\subsubsection*{Changing Routines and Home Address}
Most people will go on a vacation during the year, which means the place where they sleep changes. In general, peoples' habits will inevitably change somewhat over time, and if one compares the routine of a certain person now to what their routine looked like a year ago, it is not unlikely to be very different. However just because a user changes their routine over time, does not mean they done't currently possess one. Therefore it was chosen to base the \textit{Routine Index} was chosen to be calculated based on the last 4 weeks of data in order to base the routine overlap on more recent days.

Compare mondays to mondays

\subsubsection*{Relying on Historical Data}
In order to calculate the \textit{Routine Index} we need to save and load the historical data somehow. Two approaches were considered.\\

\textbf{\#1 Saving Stops on device:} By saving all stops for the last 4 weeks, the \textit{Places} can be found by clustering the stops with DBSCAN, and an Hour Matrix for each day in the last 4 weeks can then be computed and the average Hour Matrix can be derived from these. Afterwards the \textit{Routine Index} can be calculated as the overlap between these two, as previously described. In the field study the author had just over 70 stops per week, which corresponds to around 300 stops for a 4 week period, which is a very manageable number of elements to cluster with DBSCAN, which would be the only bottle-neck in this approach.\\

\textbf{\#2 Updating a Mean Hour Matrix:} A \textit{Mean Hour Matrix} is kept saved on disk and is updated as a weighted average every time a new day's data has been collected and the hour matrix for that day has been calculated. The number of days which the  \textit{Mean Hour Matrix} is based on will also be kept on the disk, in order to weigh the  \textit{Mean Hour Matrix} higher when calculating the new  \textit{Mean Hour Matrix}. However for this approach it becomes necessary to recalculate or at least compare today's \textit{Places} with the historical \textit{Places} every day, in order to keep track of whether the user spent time at a Place which exists in the historical matrix, or if it was a completely new place. In this approach the \textit{Places} would need to be saved in addition to a matrix with 24 rows and columns corresponding to each place. This approach may be computationally cheaper but is much more complex to implement and was therefore not chosen.

