\section{Algorithms}
These section will give an overview of the algorithms used by the Mobility Features Package. The overview will not discuss implementation details but will aim to get the core idea of each algorithm across, in addition to the considerations which were made in designing these algorithms.

\subsection{Intermediate Feature Extraction}
The intermediate features \textit{Stops}, \textit{Places} and \textit{Moves} are generated by a relatively simple process. Finding \textit{Places} and \textit{Moves} depends on the \textit{Stops} found, which means \textit{Stops} are found first. 

\subsubsection*{Stops}
Finding \textit{Stops} is done by traversing every \textit{Single Location Points} in temporal order, i.e. the timestamp is used. The \textit{Stops} for a given date are found as clusters of Single Location Points on that date with regard to the time between them, and the physical distance between them. 

\subsubsection*{Places}
\textit{Places} can now be found by applying the \textit{DBSCAN} algorithm to the \textit{Stops} found. It is important to note that if the \textit{Routine Index} for a given date over a given period is to be evaluated later on, all \textit{Stops} found for this period should be used. This means all \textit{Stops} from previous dates need to be stored on the device. 

\subsubsection*{Moves}
\textit{Moves} for a given can be calculated using the \textit{Stops}- and the \textit{Single Location Points} from that date. The \textit{Moves} are found by going through each \textit{Stop} and calculating the distance between the current \textit{Stop} and the next one by going through all the \textit{Single Location Points} which were sampled in the time interval between these two \textit{Stops}.

\subsection{Features}
The features described in the literature by \cite{Saeb2015} which can be found in Section \ref{ref:features-saeb2015}. Most of these features were simple to implement with support for real-time computation and were just a matter of performing arithmetic with regards to distance and time spent and places. However the \textit{Routine Index} \cite{Saeb2015, Canzian2015} was much more tricky to implement and it will therefore be a recurring theme discussed in this thesis.

\subsubsection*{The Routine Index}
To recap, the \textit{Routine Index} describes how similar the place-time distribution of a given day is, compared to previous days for some period of days. A concrete period length of 28 days was chosen, which means the \textit{Routine Index} of today describes how similar today was to each day during the last month. However the implementation by \cite{Canzian2015} was unnecessarily complex and as such a much more simple version was chosen for the first iteration of the software package. The \textit{Routine Index} is a scalar between 0 and 1 and can be interpreted as a similarity measure were a low value indicates little overlap and a high value indicates a high degree of overlap. 

\subsubsection*{Hour Matrix}
By representing each day as a matrix with 24 hour slots, the similarity function to compute a \textit{Routine Index} can be implemented. The time distribution for a day is defined by spending a duration of time at a certain space within a certain timeslot, i.e. spending 45 minutes at the gym between 8am and 9am. This matrix is made from all the Stops on a given day, each of which belong to certain \textit{place} and has an \textit{arrival} and \textit{
departure} timestamp. From this it can be calculated exactly which hour slot(s) to fill out and the duration to fill that slot with. For simplicity, we define a couple of constraints on the Hour Matrix:

\begin{itemize}
    \item The Hour Matrix has exactly 24 rows, each representing 1 hour in a day.
    \item The number of columns is equal to the number of \textit{Places} for the period. 
    \item An entry represents the portion of the given hour was spent at a given place.
    \item Each row can maximally sum to 1.
\end{itemize}

Formally, given a period for which the number of \textit{Places} is given as $N$ the \textit{Hour Matrix} $H$ for a given day $d$ is defined as:
$$H^d \in \mathbb{R}^{24 \times N}, H^d_{i,j} \in [0,1], \sum_{j=1}^N H^d_{i,j} \leq 1$$

Given an array of Hour Matrices for a period with $D$ days, the \textit{Mean Hour Matrix} for the period is defined as:

$$H^{\mu}_{i,j} = \sum_{d=1}^D \frac{1}{D} H^d_{i,j}$$

Lastly, we define a union operator $A \cap B$ for two matrices $A$ and $B$ as 

$$A \cap B = \sum_{i=1}^{24} \sum_{j=1}^{N} \min (A_{ij}, B_{ij}) \;|\; A_{ij} > 0, B_{ij} > 0$$

The \textit{Routine Index} of today, indexed as $t=D+1$ is computed as the overlap between the \textit{Hour Matrix} today and the \textit{Mean Hour Matrix} for the period:

$$RI^{t} = \frac{\sum (H^t \cap H^{\mu})}{\min (\sum H^t, \sum H^{\mu})}$$

This definition can be translated into words as: The actual overlap divided by the maximum potential overlap of the two matrices. While this definition is inspired by the work in \cite{Canzian2015}, it is a novel one not found in the literature. For this computation to work, the dimensions of the two matrices must be \textit{exactly the same}, and thus the number of \textit{Places} $N$ must come from the complete set of \textit{Stops} found for the period $D \cup t$. This means that for a high value of $N$, the matrices will be very sparse since one tends not to visit many \textit{Places} in a single hour slot.

\subsubsection*{Real-Time Routine Index}
If the features have to be evaluated at any point of the day, as is the case for real-time computation then the \texit{Routine Index} cannot rely on a full day of data. To make the feature represent something meaningful in real-time it would have to reflect the routine of the user up until the current time of days, i.e. if calculated at 14:00 then it should only use the first 14 rows of the matrix. This means the \textit{Routine Index} may be high early in the day since people usually sleep the same place, but then deviate somewhat from the mean as the day progresses. This can be useful to an application programmer in a recommender-system setting; one could imagine that if the \textit{Routine Index} falls below a certain threshold, a trigger can be set which will prompt the user to perform a specific action to get back on track.

\subsubsection*{What is a Routine?}
Most people will go on a vacation during the year, which means the place where they sleep changes. In general, peoples' habits will inevitably change somewhat over time, and if one compares the routine of a certain person now to what their routine looked like a year ago, it is not unlikely to be very different. However just because a user changes their routine over time, does not mean they done't currently possess one. Therefore it was chosen to base the \textit{Routine Index} was chosen to be calculated based on the last 4 weeks of data in order to base the routine overlap on more recent days. Another issue not dealt with is the fact that the routine in weekdays differ a lot from the routine during the weekend. This is especially true for people who spent 8 or more hours at work during the weekdays, and spent those 8 hours somewhere else during Saturday and Sunday, since it means the \textit{Routine Index} automatically cannot go higher than $\frac{2}{3}$ due to  8/24 hours being spent at a different place than usual. To add to this, even weekdays may look slightly different to one another, especially for those who are parts of sports clubs which meet during certain days of the week. In future work it would be interesting to investigate whether or not comparing Mondays to Mondays and vice versa for every day in the week would yield more accurate results.

\subsubsection*{Relying on Historical Data}
In order to calculate the \textit{Routine Index} we need to save and load the historical data somehow. Two approaches were considered:\\

The first approach involves keeping historical stops saved on disk. By doing so, the \textit{Places} can be found by clustering the stops with DBSCAN, and an Hour Matrix for each day in the last 4 weeks can then be computed and the average Hour Matrix can be derived from these. Afterwards the \textit{Routine Index} can be calculated as the overlap between these two, as previously described. In the field study the author had just over 70 stops per week, which corresponds to around 300 stops for a 4 week period, which is a very manageable number of elements to cluster with DBSCAN, which would be the only bottle-neck in this approach.\\

The second approach involves keeping storing the Hour Matrix for each day  on disk. However for this approach the \textit{Places} would also need to be saved such that places collected today could be compared (wrt. distance) to historical places. The reason this is necessary is to ensure that the matrix dimensions of all the matrices are the same, i.e. have the same number of columns and that these columns refer to the same place. This approach has potential to be computationally cheaper but is much more complex to implement and was therefore not chosen.

\subsection{Home Stay}
The Home Stay feature indicates the percentage of time spent at the Home cluster, out of all the time of the day. Firstly a definition for Home needs to be clear; in the literature it is defined as the cluster for which the most time is spent on average between 00:00 and 06:00 each day. However since the \textit{Home Place} may change from day to day, it was decided to let \textit{Home} for a specific day be defined as the cluster for which the most time was spent during 00:00 and 06:00 on that day only. Formally, the \textit{Home Place} $(p_h)$ for today $(t)$ is defined from today's \textit{Hour Matrix } $(H^t)$ as:

$$p_{h}^{t} = p_i \;|\; i = \operatorname*{argmax}_n(\sum_{m=1}^{6} \sum_{n=1}^{N} H^{t}_{m,n})$$

However in the literature \cite{Saeb2015, Canzian2015} it is not clear how this would be calculated for an incomplete day. A choice was made for this to be calculated using the sum of durations for all Stops belonging to today's Home cluster, divided by the time elapsed since midnight. The duration for a \textit{Stop} $s$ will be denoted $d(s)$

$$d(p_{h}^{t}) = \frac{\sum_i d(s_i) \;|\; s_i \in p_{h}^{t}}{d_{now} - d_{midnight}}$$
