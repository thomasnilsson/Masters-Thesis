\section{Storing Objects on the Device}
It was necessary to store Stops and Moves on the device, such that which rely on historic data can be computed in the future. For a single day it is also necessary to store all the data points collected on that day, on the disk, in order to minimize the risk of data loss. This was done by defining a buffer of data points which collects all incoming GPS data, and once a certain capacity is reached the data contained in the buffer is written to the disk, and the buffer is emptied.

\subsection{Serialization}
In order to save the SingleLocationPoints from today and historical Stops and Moves on the device they must be transformed from Dart objects into a data format which can store the state of the object, i.e. the information contained within it. The process of doing so is serialization and in this case Dart objects were transformed into JavaScript Object Notation (JSON) objects, which is a very common, human-readable data format that uses key-value pairs to store data. A JSON object can be stored in a database, or it can be transformed to a string in order to be stored. It was chosen to simply transform JSON objects to a string and write them to a local file, rather than storing the information in a database on the phone. The database approach is more involved and was therefore not chosen given the small scope of the project and working from a philosophy of getting a prototype up and running as fast as possible.

JSON supports a limited number of data types, such as strings, numbers, booleans, arrays, objects and null values. This means that in order to translate a Dart object to JSON, all of its fields must be serializable. An example of where this quickly becomes a problem, is with objects such as DateTime objects, since they are not supported by JSON - however a DateTime can be transformed to a number, which is milliseconds since epoch, or to an ISO standard date string. The approach is therefore to look at all the fields of the object that is to be serialized, and ensure that types of these fields all support some form of serialization. If they do not, it must be implemented.

\begin{figure}
    \centering
\begin{minted}{json}
{
    "location": {
        "latitude": 55.11787166161895,
        "longitude": 14.703046919371356
        },
    "datetime": "1586527196999"
}
\end{minted}
    \caption{Example of a serialized SingleLocationDataPoint}
    \label{fig:serialized_point}
\end{figure}

\begin{figure}
    \centering
\begin{minted}{json}
{
    "centroid": {
        "latitude": 55.11787908183754,
        "longitude": 14.703028176721789
        },
    "place_id": 0,
    "arrival": 1586556000999,
    "departure": 1586556697999
}
\end{minted}
    \caption{Example of a serialized Stop}
    \label{fig:serialized_stop}
\end{figure}

\begin{figure}
    \centering
\begin{minted}{json}
{
    "stop_from": {
        "centroid": {
            "latitude": 55.11053332998761,
            "longitude": 14.712282829580444
            },
        "place_id": 6,
        "arrival": 1586694154999,
        "departure": 1586696052001
    },
    "stop_to": {
        "centroid": {
            "latitude": 55.11793063393585,
            "longitude": 14.702982994031046
        },
        "place_id": 0,
        "arrival": 1586697230006,
        "departure": 1586699246824
    },
    "distance":2357.3408321427805
}
\end{minted}
    \caption{Example of a serialized Move}
    \label{fig:serialized_move}
\end{figure}


For loading an object from disk into application memory again it must also support de-serialization which reads values of the JSON object's keys and stores them in a Dart object. If we continue the example of a DateTime object which was serialized by either converting it to a number or a string, de-serialization must use a parser which reads the string bit by bit or use some math for calculating what day a time delta from January 1st 1970 is. 

Serialization and de-serialization is implemented by making an abstract class called Serializable, which has two functions: toJson and fromJson. The toJson function converts the object itself to a JSON object and the fromJson function is a so-called factory function which is in essence a constructor which creates a Dart object given a JSON object. The SingleLocationPoint, Stop and Move classes all implement the Serializable interface, which requires the classes to have a concrete implementation of these two methods, which in turn ensures the compiler that all of these classes can be serialized and de-serialized, which makes generalizing about objects belonging to either of these classes easier. Concretely, a generic class, Serializer<E>, was implemented in order to handle serialization, in which a type E is specified, which must a Serializable class. This makes it efficient in terms of lines of code to serialize a list of objects, since they are all required to implement toJson method, which produces a JSON object, and for de-serialization purposes they can all be constructed from a JSON object, given that it contains a set of correctly formatted key-value pairs.

