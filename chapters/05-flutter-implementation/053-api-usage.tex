\section{Using the Package}
This section will be a mirror of the official instructions on how to use the package, as of version 1.1.5.

Firstly, the programmer has to get the package by adding it as a dependency in their \verb|pubspec.yaml| file of the Flutter project. Next once the depdency has been loaded it can be imported as such

\begin{minted}{dart}
import 'package:mobility_features/mobility_features.dart';
\end{minted}

Using the package can be broken down into 4 main steps:

\subsection*{Step 1: Collect location data}
Location data collection is, as mentioned, not part of the Mobility Features package, and the programmer will therefore have tto a location plugin such as \url{https://pub.dev/packages/geolocator}. From here, each incoming location object has to be converted to a \verb|LocationSample| via the constructor
Below is shown an example where incoming \verb|Position| objects are coming in from the \verb|GeoLocator| plugin and are being handled in the \verb|_onData()| call-back method.

\begin{minted}{dart}
_onData(Position p) async {
    GeoPosition gp = GeoPosition(p.latitude, p.longitude);
    LocationSample(gp, p.timestamp);
}
\end{minted}

\subsubsection*{Step 2: Save location data}
The location data must be saved on the device such that it can be used in the future. Saving the data to persistent storage prevents it from being lost should the RAM reset. Firstly, the \verb|MobilitySerializer| must be instantiated.

\begin{minted}{dart}
MobilitySerializer<LocationSample> serializer =
      await ContextGenerator.locationSampleSerializer;
\end{minted}



Next, given that the location samples have been collected in a list `List<LocationSample> locationSamples` the data is serialized like so:

```dart
await serializer.save(locationSamples);
```

Ideally, saving the data is done with a certain interval, such as every time 100 `LocationSamples` are collected. 

\subsection*{Step 3: Compute features}
The Features can be computed using the static class `ContextGenerator` which uses the stored gps location data to compute the features.

There most basic computation is done as follows:
```dart
MobilityContext context = await ContextGenerator.generate();
```

Note: it is not possible to instantiate a `MobilityContext` object directly. 
It must be intantiated through the `ContextGenerator.generate()` method.

\subsubsection*{Step 3.1 : Compute features with prior contexts}
Should you wish to compute the Routine Index feature (see Theoretical Background) as well, then prior contexts are needed. 

Concretely, you will have to track for at least 2 days, to compute this feature.

The computation using prior contexts is done as follows

```dart
MobilityContext context = await ContextGenerator.generate(usePriorContexts: true);
```

\subsubsection*{Step 3.2: Compute features for a specific date}
By default, the `MobilityContext` object uses the current date as reference to filter 
and group data, however, should you wish to compute the features for 
a specific date, then it is possible to do so using the `today` parameter.

```dart
DateTime myDate = DateTime(01, 01, 2020);
MobilityContext context = await ContextGenerator.generate(today: myDate);
```

\subsection*{Step 4: Get features}
All features are implemented as getters for the `MobilityContext` object.

```dart
context.places;
context.stops;
context.moves;

context.numberOfPlaces;
context.homeStay;
context.entropy;
context.normalizedEntropy;
context.distanceTravelled;
context.routineIndex;
```