\section{Using the Package}
This section will be a mirror of the official instructions on how to use the package, as of version 1.1.5.

Firstly, the programmer has to get the package by adding it as a dependency in their \verb|pubspec.yaml| file of the Flutter project. Next once the dependency has been loaded it can be imported as such

\begin{minted}{dart}
import 'package:mobility_features/mobility_features.dart';
\end{minted}

Using the package can be broken down into 4 main steps:

\subsection*{Step 1: Collect location data}
Location data collection is, as mentioned, not part of the Mobility Features package, and the programmer will therefore have tto a location plugin such as \url{https://pub.dev/packages/geolocator}. From here, each incoming location object has to be converted to a \verb|LocationSample| via the constructor
Below is shown an example where incoming \verb|Position| objects are coming in from the \verb|GeoLocator| plugin and are being handled in the \verb|_onData()| call-back method.

\begin{minted}{dart}
_onData(Position p) async {
    GeoPosition gp = GeoPosition(p.latitude, p.longitude);
    LocationSample(gp, p.timestamp);
}
\end{minted}

\subsubsection*{Step 2: Save location data}
The location data must be saved on the device such that it can be used in the future. Saving the data to persistent storage prevents it from being lost should the RAM reset. Firstly, the \verb|MobilitySerializer| must be instantiated.

\begin{minted}{dart}
MobilitySerializer<LocationSample> serializer =
      await ContextGenerator.locationSampleSerializer;
\end{minted}

Next, given that the programmer has a collected the samples in a list \verb|List<LocationSample> locationSamples| the samples can be serialized using the \verb|save()| method of the MobilitySerializer.

\begin{minted}{dart}
await serializer.save(locationSamples);
\end{minted}

Ideally, saving the data is done with a certain interval, such as every time 100 samples are collected. 

\subsection*{Step 3: Compute features}
The Features can be computed using the static class \verb|ContextGenerator| which uses the stored location samples, as well as  historic features to compute the features for today.

There most basic computation is done as follows:
\begin{minted}{dart}
MobilityContext context = await ContextGenerator.generate();
\end{minted}

Note: it is not possible to instantiate a `MobilityContext` object directly. 
It must be intantiated through the `ContextGenerator.generate()` method.

\subsubsection*{Step 3.1 : Compute features with prior contexts}
Should the programmer wish to compute the \textit{Routine Index} feature as well, then prior contexts are needed. Concretely, the application needs to have tracked data for at least 2 days, to compute this feature. The generation of a Mobility Context using prior contexts is done using the \verb|usePriorContexts| argument and setting it to \verb|true|.

\begin{minted}{dart}
MobilityContext context = 
    await ContextGenerator.generate(usePriorContexts: true);
\end{minted}

\subsubsection*{Step 3.2: Compute features for a specific date}
By default, a \textit{MobilityContext} object uses the current date as reference to filter and group data, however, should one wish to compute the features for a specific date, then it is possible to do so using the \verb|today| argument and providing the desired date.

\begin{minted}{dart}
DateTime myDate = DateTime(01, 01, 2020);
MobilityContext context = 
    await ContextGenerator.generate(today: myDate);
\end{minted}

\subsection*{Step 4: Get features}
All features are implemented as \textit{getters} for the MobilityContext class and can therefore be retrieved using the dot-notation. 

\begin{minted}{dart}
MobilityContext context = // Generate context

List<Place> places = context.places;
List<Stop> stops = context.stops;
List<Move> moves = context.moves;

int numberOfPlaces = context.numberOfPlaces;
double homeStay = context.homeStay;
double entropy = context.entropy;
double normalizedEntropy = context.normalizedEntropy;
double distanceTravelled = context.distanceTravelled;
double routineIndex = context.routineIndex;
\end{minted}