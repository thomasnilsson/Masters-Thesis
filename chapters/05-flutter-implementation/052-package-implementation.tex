\section{Package Implementation}
The package was implemented in Flutter according to the design in Chapter \ref{chapter:04} in which a series of components and the overall data model was outlined. This section will go through selected examples of source code as well as the general principles applied, to achieve the specified design, when implementing in Flutter and Dart.

\subsection{Private and Public Access}
In most objective oriented languages, such as Dart, the safest way to use fields in classes is to make them private, and to implement a parameter-less 'getter' method for retrieving the value, and a 'setter' method which takes in the new value as its parameter. In the Dart programming language, a field is declared private by having the the underscore prefix, i.e. \verb|routineIndex| becomes \verb|_routineIndex|, and the corresponding getter method is declared with \verb|get| and is simply called the \verb|routineIndex|:

\begin{minted}{java}
class MobilityContext {

  /// Features
  double _routineIndex;
  ...
  double get routineIndex {
    return _routineIndex;
  }
}
\end{minted}

This results in an easy-to-read syntax when getting the value of the field, which looks like this:

\begin{minted}{dart}
MobilityContext c = MobilityContext(...);
print(c.routineIndex);
\end{minted}

The same concept can be applied to a constructor as well as the whole class. A public constructor is declared as:
\begin{minted}{dart}
GeoPosition(this._latitude, this._longitude);
\end{minted}

With the private equivalent being:

\begin{minted}{dart}
GeoPosition._(this._latitude, this._longitude);
\end{minted}

A private constructor allows the class to be publicly \textit{available} but not publicly \textit{instantiable}. For classes the underscore prefix is used for the class name, to make it private, similar to field, i.e. \verb|class HourMatrix| becomes \verb|class _HourMatrix|.

\subsection{Domain Model Implementation}
All the components specified in the Domain Model Chapter \ref{chapter:04} were implemented with their repsective relations to each other. As specified in the component diagram \ref{fig:component-diagram} the only component with a public-facing constructor was LocationSample, and by transitivity, also GeoPosition. This is done, as mentioned, to allow the user instantiate a LocationSample with data from a given Location DTO. The GeoPosition class a field for the latitude and one for the longitude and a fundamental class used by the GeoSpatial interface. 

\begin{minted}{dart}
abstract class _Geospatial {
  GeoPosition get geoPosition;
}
\end{minted}

This interface allows other classes to promise the Dart compiler that it has a GeoPosition field which allows it to be compared to other classes which implement the same interface. In Dart interfaces and abstract classes are one and the same thing, and the \textit{abstract class} keyword is used for implementing them. The GeoPosition class even implements this interface since a GeoPosition object itself has a GeoPosition. This may seem superfluous, but will come in handy when finding Stops.

\begin{minted}{dart}
class GeoPosition implements _Serializable, _Geospatial {
  double _latitude;
  double _longitude;

  GeoPosition(this._latitude, this._longitude);

  GeoPosition get geoPosition => this;
  double get latitude => _latitude;
  double get longitude => _longitude;
}
\end{minted}

\subsection{Storing and Loading Data}
The storing and loading of data, which includes Location Samples, Stops and Moves happen through the MobilitySerializer class. 

The usage of the interface is found in the Serializer class, which is utility class for serializing and de-serializing a list of objects which implement the Serializable interface.

The class is a generic which allows the type \verb|E| to be specified later, with \verb|E| referring to either an Location Sample, Stop or Move which all implement the Serializable interface. The Serializer is constructed using a reference to a File object, which allows the Serializer to be unit tested (which is done in a desktop environment) as well as used in a mobile phone environment. Both of these environments have different ways of handling the file system, which means it is better to pass a file reference, rather than simply a file name, since how files are accessed depends on the file system. Concretely a Serializer object is defined as follows:

Store collected samples
Load collected samples
Filter collected samples
Data from day $n$ is deleted on day $n+1$ when loading

Load historical stops and moves
Filter stops and moves
Recompute for today, replace with new 
Append the filtered historical with new stops and moves
Store by overwriting existing stops and moves

Serializable interface, tojson and fromjson methods
reflection, could have been prettier

\subsection{Finding Stops, Moves and Places}
Stops, geospatial interface
Algorithms described in Chapter \ref{chapter:03}.
Places need to be recomputed each time the period is extended

\subsection{Computing Features}
Mobility context class
Cannot be directly instantiated
Features derived from intermediate features
Lazy evaluation

\subsection{Routine Index and Context Generation}
Context Generator
Static class, does not have a state
References the LocationSample serializer, gives access to the user
Works as interface for computing things without being able to alter the state
Does the computation process
Async, since files need to be stored and loaded

\subsection{Improvements}
Currently the implementation (not the design) requires daily computation
If features are not computed on a given day, then all the data collected on that day will be lost next time features are computed due to being filtered out. Currently the user can avoid this by either computing features every day without fault or specifying the date on which the features are yet to be computed.
The fix is to mark data and not throw it out before stops and moves have been evaluated for those samples
When data is loaded, group by date, and compute stops and moves per date. Only then should the samples be thrown out.

Lazy evaluation should probably not be used, instead compute on initialization since initialization is async

ContextGeneration should be done with an isolate, currently the user needs to use an isolate.
Prevent UI thread from freezing