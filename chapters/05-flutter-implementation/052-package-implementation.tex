\section{Package Implementation}
The package was implemented in Flutter according to the design in Chapter \ref{chapter:04} in which a series of components and the overall data model was outlined. This section will go through selected examples of source code as well as the general principles applied, to achieve the specified design, when implementing in Flutter and Dart.

\subsection{Private and Public Access}
In most objective oriented languages, such as Dart, the safest way to use fields in classes is to make them private, and to implement a parameter-less 'getter' method for retrieving the value, and a 'setter' method which takes in the new value as its parameter. In the Dart programming language, a field is declared private by having the the underscore prefix, i.e. \verb|routineIndex| becomes \verb|_routineIndex|, and the corresponding getter method is declared with \verb|get| and is simply called the \verb|routineIndex|:

\begin{minted}{java}
class MobilityContext {

  /// Features
  double _routineIndex;
  ...
  double get routineIndex {
    return _routineIndex;
  }
}
\end{minted}

This results in an easy-to-read syntax when getting the value of the field, which looks like this:

\begin{minted}{dart}
MobilityContext c = MobilityContext(...);
print(c.routineIndex);
\end{minted}

The same concept can be applied to a constructor as well as the whole class. A public constructor is declared as:
\begin{minted}{dart}
GeoPosition(this._latitude, this._longitude);
\end{minted}

With the private equivalent being:

\begin{minted}{dart}
GeoPosition._(this._latitude, this._longitude);
\end{minted}

A private constructor allows the class to be publicly \textit{available} but not publicly \textit{instantiable}. For classes the underscore prefix is used for the class name, to make it private, similar to field, i.e. \verb|class HourMatrix| becomes \verb|class _HourMatrix|.

On the note of constructors, this package makes use of factory constructors which are effectively just methods which generate an object using the normal constructor. A factory constructor may be used to construct an object from JSON data, where each relevant field is extracted from the JSON data and passed onto the real constructor. A factory constructor is defined as follows:
\begin{minted}{dart}
factory Stop._fromLocationSamples(...) {
	return Stop._(...);
}
\end{minted}

\subsection{Domain Model Implementation}
All the components specified in the Domain Model Chapter \ref{chapter:04} were implemented with their repsective relations to each other. As specified in the component diagram \ref{fig:component-diagram} the only component with a public-facing constructor was LocationSample, and by transitivity, also GeoPosition. This is done, as mentioned, to allow the user instantiate a LocationSample with data from a given Location DTO. The GeoPosition class a field for the latitude and one for the longitude and a fundamental class used by the GeoSpatial interface. The interface is a private abstract class which means it is only visible internally in the package library.

\begin{minted}{dart}
abstract class _Geospatial {
  GeoPosition get geoPosition;
}
\end{minted}

This interface allows other classes to promise the Dart compiler that it has a GeoPosition field which allows it to be compared to other classes which implement the same interface. In Dart interfaces and abstract classes are one and the same thing, and the \textit{abstract class} keyword is used for implementing them. The GeoPosition class even implements this interface since a GeoPosition object itself has a GeoPosition. This may seem superfluous, but will come in handy when finding Stops.

\begin{minted}{dart}
class GeoPosition implements _Serializable, _Geospatial {
  double _latitude;
  double _longitude;

  GeoPosition(this._latitude, this._longitude);

  GeoPosition get geoPosition => this;
  double get latitude => _latitude;
  double get longitude => _longitude;
}
\end{minted}

\subsection{Storing and Loading Data}
The storing and loading of data, which includes Location Samples, Stops and Moves happen through the MobilitySerializer class. This class allows classes which implement the Serializable interface to be serialized and de-serialized. Just like the GeoSpatial interface, the Serializable interface is also implemented as a private abstract class only used internally in the package library. The interface contains a method for serializing a class to JSON, named \verb|toJson()| which takes no parameters and produces a HashMap of Strings to the dynamic, the dynamic type meaning any type. This is the Dart equivalent of a JSON object. Another method the interface forces other classes to implement is the deserialization method \verb|fromJson(json)| which takes a JSON object as parameter and creates a runtime object of the given type, from the JSON object. The implemention of this method is left to the individual classes implementing the interface which is done by extracting data from the JSON object.

\begin{minted}{dart}
abstract class _Serializable {
  Map<String, dynamic> _toJson();

  _Serializable._fromJson(Map<String, dynamic> json);
}
\end{minted}

The MobilitySerializer class is a generic which allows the type \verb|E| to be specified later, with \verb|E| referring to either an Location Sample, Stop or Move which all implement the Serializable interface. The MobilitySerializer is constructed using a reference to a File object. The File object is used for storing the data of the given type i.e. Location Samples are stored one file, Stops in another and Moves in a third.

\begin{minted}{dart}
class MobilitySerializer<E> {
  File file;
  
  MobilitySerializer._(this.file) {
    bool exists = file.existsSync();
    if (!exists) {
      flush();
    }
  }
  
  Future<void> flush() async =>
      await file.writeAsString('', mode: FileMode.write);
\end{minted}

When initialized, it is checked whether or not the specified file exists, and if not the \verb|flush| method is called, which simply writes an empty string to the file, overriding any content, which has the effect of creating the file, should it not already exist. A concrete example of instantiated the MobilitySerializer for Stops is shown below, where \textit{stops.json} refers to the file in which Stops should be stored.

\begin{minted}{dart}
MobilitySerializer<Stop> stopSerializer =
        MobilitySerializer<Stop>._(await _file('stops.json'));
\end{minted}

For storing data the \verb|save| method is used which takes in a list of objects which all implement the Serializable interface. Each element in the list is serialized via its \verb|toJson| method and concatenated into one big string separated by a delimiter token, and this string is then written to the specific file of the MobilitySerializer object.

\begin{minted}{dart}
Future<void> save(List<_Serializable> elements) async {
  String jsonString = "";
  for (_Serializable e in elements) {
    jsonString += json.encode(e._toJson()) + delimiter;
  }
  await file.writeAsString(jsonString, mode: FileMode.writeOnlyAppend);
}
\end{minted}

Loading works in the reverse order, where the contents of the specified file is loaded into a string, the string is then split into elements using the delimiter token and each of these elements is turn de-serialized using the \verb|fromJson| method.  For deciding which type to de-serialize the elements into, a switch statement is used that checks the type of \verb|E| which is specified when the MobilitySerializer object is instantiated.

\begin{minted}{dart}
Future<List<_Serializable>> load() async {
    String content = await file.readAsString();

    List<String> lines = content.split(delimiter);

    Iterable<Map<String, dynamic>> jsonObjs = lines
        .sublist(0, lines.length - 1)
        .map((e) => json.decode(e))
        .map((e) => Map<String, dynamic>.from(e));

    switch (E) {
      case Move:

        return jsonObjs.map((x) => Move._fromJson(x)).toList();
      case Stop:

        return jsonObjs.map((x) => Stop._fromJson(x)).toList();
      default:

        return jsonObjs.map((x) => LocationSample._fromJson(x)).toList();
    }
  }
\end{minted}

Ideally, the switch statement could have been replaced by the following one-liner:
\begin{minted}{dart}
return jsonObjs.map((x) => E.fromJson(x)).toList();
\end{minted}

However, this relies on the language feature called reflection \footnote{\url{https://www.javaworld.com/article/2075801/reflection-vs--code-generation.html}} which allows the compiler to infer the type of \verb|E| at compile-time. However, Dart does not support \textit{reflection} which makes this impossible.

\subsection{Finding Intermediate Features}
Finding the intermediate features Stops, Moves and Places were done according to the algorithms described in Chapter \ref{chapter:03}. 

\subsubsection{Finding Stops}
The Stop class has two constructors: A factory constructor which takes a set of LocationSamples from which the centroid of the set is computed, as well as the earliest timestamp, which will be the arrival time, and the latest timestamp which will be the departure time. After these attributes are found, the normal constructor is used.

\begin{minted}{dart}
  factory Stop._fromLocationSamples(List<LocationSample> locationSamples,
      {int placeId = -1}) {
      
    GeoPosition center = _computeCentroid(locationSamples);
    return Stop._(center, locationSamples.first.datetime, locationSamples.last.datetime,
        placeId: placeId);
  }
\end{minted}

The normal constructor uses a GeoPosition, in addition to an arrival and departure time. A place ID may also be specified at construction, but often it is not yet known at construction time hence it is optional.

\begin{minted}{dart}
  Stop._(this._geoPosition, this._arrival, this._departure, {this.placeId = -1});
\end{minted}

The Stop algorithm takes a List of LocationSamples as input, and uses two while-loops, and two pointers (\textit{start} and \textit{end}) which delimit a subset of the input data we are currently considering with the outer loop. Every time the outer loop moves, the \textit{start} pointer is moved past the end pointer, in order to skip already seen data. The inner loop is responsible for moving the \textit{end} pointer: With each iteration of the inner loop, the centroid of the current subset is computed. If the distance from this centroid to the latest added sample is within the given \verb|stopRadius| parameter, then the subset is expanded by incrementing the \textit{end} pointer., and the process is continued. Otherwise the inner loop terminates and a Stop is created from the subset. The Stop is created without a Place ID, since Places have not yet been identified. In addition, Stops with a duration shorter than the duration specified by the \verb|stopDuration| parameter are removed since they are noisy. This is an addition to the algorithms previously described and is mostly used due to the very high sampling frequency and likely won't be necessary in the general case.

\begin{minted}{dart}
  int start = 0;
  while (start < n) {
    int end = start + 1;
    List<LocationSample> subset = data.sublist(start, end);
    GeoPosition centroid = _computeCentroid(subset);

    while (
        end < n && Distance.fromGeospatial(centroid, data[end]) <= stopRadius) {
      end += 1;
      subset = data.sublist(start, end);
      centroid = _computeCentroid(subset);
    }
    Stop s = Stop._fromLocationSamples(subset);
    stops.add(s);

    start = end;
  }
\end{minted}

The distance calculation \verb|Distance.fromGeospatial(centroid, data[end]) <= stopRadius)| is carried out using the \verb|GeoSpatial| interface previously mentioned. The distance function \verb|fromGeoSpatial| takes two objects which implement the interface and unpacks the latitude and longitude from these objects. The haversine distance can then be computed afterwards.

\begin{minted}{dart}
class Distance {
  static double fromGeospatial(_Geospatial a, _Geospatial b) {
    return fromList(
        [a.geoPosition._latitude, a.geoPosition._longitude],
        [b.geoPosition._latitude, b.geoPosition._longitude]);
  }

  static double fromList(List<double> p1, List<double> p2) {
    /// Haversine implementation
  }
}
\end{minted}

\subsubsection{Finding Moves}
The Move class has two constructors which are both private. Common for both constructors is that they take two Stops as arguments, with argument being either a path of Locaiton Samples or a Distance, i.e. a double. The factory constructor called \verb|_fromPath| calculates the distance of the path and then uses the normal constructor for create a Move. 
\begin{minted}{dart}
  factory Move._fromPath(Stop a, Stop b, List<LocationSample> path) {
    double d = _computePathDistance(path);
    return Move._(a, b, d);
  }
\end{minted}

\begin{minted}{dart}
  Move._(this._stopFrom, this._stopTo, this._distance);
\end{minted}
The normal constructor is used for de-serialization whereas the factory constructor is used to create a Move given two Stops and the path of samples between them.

The algorithm for finding Moves takes a List of Location Samples and the Stops found from the samples as input. The algorithm first checks if the set of Stops is empty, and if so returns an empty set of Moves. If however the set of Stops is not empty, then two 'fake' Stops are created and added to the set of Stops. These two additional stops are created from the first and last element in the set of Location Samples. For each Stop in the set of Stops, it is calculated which samples lie in between the current and next Stop. A Move is then created using the current Stop, the next Stop and the path between. 

\begin{minted}{dart}
  Stop first = Stop._fromLocationSamples([data.first]);
  List<Stop> allStops = [first] + stops;

  if (data.first != data.last) {
    Stop last = Stop._fromLocationSamples([data.last]);
    allStops.add(last);
  }

  for (int i = 0; i < allStops.length - 1; i++) {
    Stop cur = allStops[i];
    Stop next = allStops[i + 1];
    List<LocationSample> samplesInBetween = data
        .where((d) =>
            cur.departure.leq(d.datetime) && d.datetime.leq(next.arrival))
        .toList();

    moves.add(Move._fromPath(cur, next, samplesInBetween));
  }
\end{minted}

The mentioned 'fake' Stops is an addition to the definition in Chapter \ref{chapter:03}. They are created to avoid situations in which tracking was started while moving, in this case no Moves are created before the user is stationary for some time, and Stops are found. This situation will likely not be very common, but was found during self-study and therefore deemed worthy of covering. The extra Stops are only used for finding moves and will not be used for finding Places.

\subsubsection{Finding Places}
The Place class only has one normal constructor which takes an ID (an integer) and a List of Stops. 
\begin{minted}{dart}
Place._(this._id, this._stops);
\end{minted}

The Place algorithm takes a set of Stops for a given period, i.e. Stops over multiple days. The DBSCAN algorithm \cite{density-based-1996} is used to find clusters in the Stops and label each Stop with a cluster ID, this is the place ID previously discussed. Once the labels are computed the Stops are grouped by their Place ID, and a for each group a Place object is created with the group label and the Stops contained in the group. Lastly, the \verb|placeId| attribute for each Stop in the group is set to the group label.

\begin{minted}{dart}
  DBSCAN dbscan = DBSCAN(
      epsilon: placeRadius, minPoints: 1, distanceMeasure: Distance.fromList);
  List<List<double>> stopCoordinates =
      stops.map((s) => ([s.geoPosition.latitude, s.geoPosition.longitude])).toList();

  dbscan.run(stopCoordinates);

  Set<int> clusterLabels = dbscan.label.where((l) => (l != -1)).toSet();

  for (int label in clusterLabels) {
    List<int> indices =
        stops.asMap().keys.where((i) => (dbscan.label[i] == label)).toList();

    List<Stop> stopsForPlace = indices.map((i) => (stops[i])).toList();

    Place p = Place._(label, stopsForPlace);
    places.add(p);

    stopsForPlace.forEach((s) => s.placeId = p._id);
  }
\end{minted}

\subsection{Using Historical Data}
Store collected samples
Load collected samples
Filter collected samples
Data from day $n$ is deleted on day $n+1$ when loading

Load historical stops and moves
Filter stops and moves
Recompute for today, replace with new 
Append the filtered historical with new stops and moves
Store by overwriting existing stops and moves

\subsection{Context Generation}
Context Generator
Static class, does not have a state
References the LocationSample serializer, gives access to the user
Works as interface for computing things without being able to alter the state
Does the computation process
Async, since files need to be stored and loaded


\subsection{Computing Features}
Mobility context class
Cannot be directly instantiated
Features derived from intermediate features
Lazy evaluation
Routine Index

\subsection{Improvements}
Currently the implementation (not the design) requires daily computation
If features are not computed on a given day, then all the data collected on that day will be lost next time features are computed due to being filtered out. Currently the user can avoid this by either computing features every day without fault or specifying the date on which the features are yet to be computed.
The fix is to mark data and not throw it out before stops and moves have been evaluated for those samples
When data is loaded, group by date, and compute stops and moves per date. Only then should the samples be thrown out.

Lazy evaluation should probably not be used, instead compute on initialization since initialization is async

ContextGeneration should be done with an isolate, currently the user needs to use an isolate.
Prevent UI thread from freezingMobilitySerializvi